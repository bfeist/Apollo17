<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="keywords" content="template" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<link rel="copyright" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" />

	<title>TOC</title>
	<meta name="robots" content="index,follow" />
	<style type="text/css" media="screen,projection"></style>
	<link rel="stylesheet" type="text/css" href="styles.css" />
	
	<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.js"></script>

    <script language="javascript" type="text/javascript">
		var lastTimeId = '';
		var lastTimeIdChecked = '';
		var intervalID = null;
		var YTList = [];
		var currVideoStartSeconds = 0;
        var currVideoEndSeconds = 0;

        var tag = document.createElement('script');

        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);        

        // This function creates an <iframe> (and YouTube player) after the API code downloads.
        var player;
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('player', {
                height: '520',
                width: '720',
                videoId: 'ccHq1hv0ohk',
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange
                }
            });
        }

        // The API will call this function when the video player is ready.
        function onPlayerReady(event) {
            event.target.playVideo();
            seekToTime("timeid0000000");
        }

        // The API calls this function when the player's state changes.
        // The function indicates that when playing a video (state=1)
        var initialPlay = true;
        function onPlayerStateChange(event) {
            console.log("player state change: " + event.data);
            if (event.data == YT.PlayerState.PLAYING && initialPlay) {
				player.seekTo(0, true);
				initialPlay = false;
			}
            if (event.data == YT.PlayerState.PLAYING && intervalID == null ) {
				//poll for mission time scrolling if video is playing
				intervalID = setAutoScrollPoller();
				console.log("interval started: " + intervalID);
			} else if (event.data == YT.PlayerState.PAUSED) {
				//clear polling for mission time scrolling if video is paused
				window.clearInterval(intervalID);
				console.log("interval stopped: " + intervalID);
				intervalID = null;
			}
            if (event.data == YT.PlayerState.BUFFERING) {
                console.log("buffering: " + event.target.getCurrentTime() + currVideoStartSeconds);
                //findClosestUtterance(event.target.getCurrentTime() + currVideoStartSeconds);
            }
            if (event.data == YT.PlayerState.ENDED) {
                var currVideoID = player.getVideoUrl().substr(32,11);
                var secsPositiveMultiplier = 1;
                for (var i = 0; i < YTList.length; ++i) {
                    if (YTList[i][1] == currVideoID) {
                        console.log("End of video. Changing YT video from: " + currVideoID + " to: " + YTList[i + 1][1]);
                        currVideoID = YTList[i + 1][1];
                        break;
                    }
                }
                var itemStartTimeArray = YTList[i + 1][2].split(":");
                var startHours = parseInt(itemStartTimeArray[0]);
                var startMinutes = parseInt(itemStartTimeArray[1]);
                var startSeconds = parseInt(itemStartTimeArray[2]);
                if (startHours < 0) {
                    secsPositiveMultiplier = -1;
                } else {
                    secsPositiveMultiplier = 1;
                }
                currVideoStartSeconds = secsPositiveMultiplier * (Math.abs(startHours) * 60 * 60 + startMinutes  * 60 + startSeconds);

                var itemEndTimeArray = YTList[i + 1][3].split(":");
                var endHours = parseInt(itemEndTimeArray[0]);
                var endMinutes = parseInt(itemEndTimeArray[1]);
                var endSeconds = parseInt(itemEndTimeArray[2]);
                if (endHours < 0) {
                    secsPositiveMultiplier = -1;
                } else {
                    secsPositiveMultiplier = 1;
                }
                currVideoEndSeconds = secsPositiveMultiplier * (Math.abs(endHours) * 60 * 60 + endMinutes * 60 + endSeconds);

                player.loadVideoById(currVideoID, 0);

                window.clearInterval(intervalID); //reset the scrolling poller for the new video
                intervalID = setAutoScrollPoller();
            }
		}

        function stopVideo() {
            player.stopVideo();
        }

        function seekTo10Min() {
            player.seekTo(600, true);
			scrollToTimeID('timeid0001002');
			
			//$('#iFrameTranscript').contents().scrollTop($('#iFrameTranscript').contents().find('#timeid0001002').offset().top);
			//$('#timeid0001002').goTo();		
        }

		//jQuery plugin function to check if a content item exists
		$.fn.exists = function () {
			return this.length !== 0;
		}

        //--------------- search for closest utterance time to seeked video --------------------
        function findClosestUtterance(totalSecSearch) {
            var found = false;
            var onCountdown = false;
            var curSecSearch = totalSecSearch;
            var transcriptFrame = $('#iFrameTranscript').contents();
            if (totalSecSearch < 0) {
                onCountdown = true; //if on the countdown video counting backwards, make all times positive for timecode generation, then add the negative to the search string
            }
            while (!found) {
                var hours = Math.abs(parseInt(curSecSearch / 3600));
                var minutes = Math.abs(parseInt(curSecSearch / 60)) % 60;
                var seconds = Math.abs(parseInt(curSecSearch)) % 60;
                seconds = Math.floor(seconds);

                var timeId = (hours < 10 ? "00" + hours : hours < 100 ? "0" + hours : hours) +
                        (minutes < 10 ? "0" + minutes : minutes) +
                        (seconds < 10 ? "0" + seconds : seconds);
                timeId = "timeid" + timeId;
                if (onCountdown) {
                    timeId = timeId.substr(0,6) + "-" + timeId.substr(7); //change timeid to negative, replacing leading tripple hours zero with "-"
                }

                if (transcriptFrame.find('#' + timeId).exists()) {
                    found = true;
                    console.log("found: " + timeId);
                    scrollToTimeID(timeId);
                    break;
                } else {
                    //console.log("not found: " + timeId);
                    if (currVideoStartSeconds >= 0) {
                        curSecSearch--;
                    } else {
                        curSecSearch++; //if we're on the countdown, search forward in time for the closest utterance
                    }
                }
            }
        }

		//--------------- transcript iframe autoscroll handling --------------------

		function setAutoScrollPoller() {
			return window.setInterval(function () {
                var onCountdown = false;
				var totalSec = player.getCurrentTime() + currVideoStartSeconds;
                if (totalSec < 0) {
                    onCountdown = true; //if on the countdown video counting backwards, make all times positive for timecode generation, then add the negative to the search string
                }
				var hours = Math.abs(parseInt(totalSec / 3600));
				var minutes = Math.abs(parseInt(totalSec / 60)) % 60 % 60;
				var seconds = Math.abs(parseInt(totalSec)) % 60;
				seconds = Math.floor(seconds);

				timer.innerText = (hours < 10 ? "00" + hours : hours < 100 ? "0" + hours : hours) +
                        (minutes < 10 ? "0" + minutes : minutes) + ":" +
                        (seconds < 10 ? "0" + seconds : seconds);

                var timeId = "timeid" + (hours < 10 ? "00" + hours : hours < 100 ? "0" + hours : hours) +
						(minutes < 10 ? "0" + minutes : minutes) +
						(seconds < 10 ? "0" + seconds : seconds);

                if (onCountdown) {
                    timeId = timeId.substr(0,6) + "-" + timeId.substr(7); //change timeid to negative, replacing leading tripple hours zero with "-"
                }

				if (timeId != lastTimeIdChecked) {
					console.log("totalsec: " + totalSec + "| divmarker: " + timeId);
					lastTimeIdChecked = timeId;
					scrollToTimeID(timeId);
				}
			}, 500); //polling frequency in milliseconds
		}
		
		function scrollToTimeID(timeId) {
			//console.log ('#' + timeId + ' - ' + $('#iFrameTranscript').contents().find('#' + timeId).length);
			var transcriptFrame = $('#iFrameTranscript').contents();
			if (transcriptFrame.find('#' + timeId).exists()) {
				//reset background color of last line
				if (lastTimeId != '') {
					transcriptFrame.find('#' + lastTimeId).css("background-color","#FFFFFF");
				}

				var timeIdMarker = transcriptFrame.find('#' + timeId);
				var scrollDestination = timeIdMarker.offset().top - 50;
				timeIdMarker.css("background-color","#DDDDDD");
				transcriptFrame.find('body').animate({ scrollTop: scrollDestination }, 300);
				lastTimeId = timeId;
			}
		}
		//--------------- transcript click handling --------------------

		function seekToTime(elementId){
            var secsPositiveMultiplier = 1;
            var timeStr = elementId.substr(6,7);
            var sign = timeStr.substr(0,1);
            var hours = parseInt(timeStr.substr(0,3));
            var minutes = parseInt(timeStr.substr(3,2));
            var seconds = parseInt(timeStr.substr(5,2));
            if (sign == "-") {
                secsPositiveMultiplier = -1;
            } else {
                secsPositiveMultiplier = 1;
            }
			var totalSeconds = (Math.abs(hours) * 60 * 60) + (minutes * 60) + seconds;
            totalSeconds = totalSeconds * secsPositiveMultiplier;

			var currVideoID = player.getVideoUrl().substr(32,11);
			//console.log(currVideoID);
			for (var i = 0; i < YTList.length; ++i) {
				var itemStartTimeArray = YTList[i][2].split(":");
                var startHours = parseInt(itemStartTimeArray[0]);
                var startMinutes = parseInt(itemStartTimeArray[1]);
                var startSeconds = parseInt(itemStartTimeArray[2]);
                if (startHours < 0) {
                    secsPositiveMultiplier = -1;
                } else {
                    secsPositiveMultiplier = 1;
                }
                var itemStartTimeSeconds = secsPositiveMultiplier * (Math.abs(startHours) * 60 * 60 + startMinutes  * 60 + startSeconds);
                var itemEndTimeArray = YTList[i][3].split(":");
                var endHours = parseInt(itemEndTimeArray[0]);
                var endMinutes = parseInt(itemEndTimeArray[1]);
                var endSeconds = parseInt(itemEndTimeArray[2]);
                if (endHours < 0) {
                    secsPositiveMultiplier = -1;
                } else {
                    secsPositiveMultiplier = 1;
                }
                var itemEndTimeSeconds = secsPositiveMultiplier * (Math.abs(endHours) * 60 * 60 + endMinutes * 60 + endSeconds);

                if (totalSeconds >= itemStartTimeSeconds && totalSeconds < itemEndTimeSeconds) { //if this item in loop contains the time we want to seek to

					var seekToSecondsWithOffset = totalSeconds - itemStartTimeSeconds;
                    //adjust for 000:02:40 time addition at 065:00:00 -- only the 65 hours-in video needs this manual adjustment, all others have their startTime listed including the time change
                    if (itemStartTimeSeconds == 230400) {
                        if (seekToSecondsWithOffset > 3600) { //if at 065:00:00 or greater, add 000:02:40 to time
                            seekToSecondsWithOffset = seekToSecondsWithOffset - 9600;
                        }
                    }
					currVideoStartSeconds = itemStartTimeSeconds;
                    currVideoEndSeconds = itemEndTimeSeconds;
                    //change youtube video if the correct video isn't already playing
					if (currVideoID !== YTList[i][1]) {
                        console.log("changing YT video from: " + currVideoID + " to: " + YTList[i][1]);

						player.loadVideoById(YTList[i][1], seekToSecondsWithOffset);
						window.clearInterval(intervalID); //reset the scrolling poller for the new video
						intervalID = setAutoScrollPoller();
					} else {
                        console.log("no need to change video. Seeking to " + elementId.toString());
						player.seekTo(seekToSecondsWithOffset, true);
					}
					break;
				}
			}
		}

		//		document.getElementById("iFrameTranscript").onload = function() {
//			$('#iFrameTranscript').contents().find('div.utterance').each(function(index, element) {
//				console.log(index + ": " + $(element).text());
//			});
//		});


		//--------------- youtube index file handling --------------------
		$(document).ready(function() {
			$.ajax({
				type: "GET",
				url: "./YouTube_media_index.csv",
				dataType: "text",
				success: function(data) {processYTData(data);}
			});
		});

		function processYTData(allText) {
			var allTextLines = allText.split(/\r\n|\n/);

			for (var i = 0; i < allTextLines.length; i++) {
				var data = allTextLines[i].split('|');

				var rec = [];
				rec.push(data[0]);
				rec.push(data[1]);
				rec.push(data[2]);
				rec.push(data[3]);
				YTList.push(rec);
			}
			// alert(lines);
		}

		
    </script>
</head>

<body>

    <!--<div id="topBar"> <a href ="#" onclick="load_toc()"> Load TOC </a> </div> -->
    <div style="float: left; width: 50%">
        <iframe src="TOC.html" style="border:1px #000000 none;" id="iFrameTOC" name="iFrameTOC" scrolling="yes" frameborder="1" marginheight="5px" marginwidth="5px" height="500px" width="100%"></iframe>
    </div>
    <div style="float: right; width: 640px;" id="player">
	</div>
	<div id="timer">00</div>
	<div id="debug" onclick="seekTo10Min()">Skip to 000:10:00</div>
    <div style="width: 100%;">
        <iframe src="allUtterances.html" style="border:1px #000000 none;" name="iFrameTranscript" id="iFrameTranscript" scrolling="yes" frameborder="1" marginheight="5px" marginwidth="5px" height="470px" width="100%"></iframe>
    </div>

</body>
</html>